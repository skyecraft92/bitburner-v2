/** @param {NS} ns */
export async function main(ns) {
    const analysisOutputFile = "network_analysis.txt";
    const connectionMapFile = "network_connect_map.txt";
    const scanInterval = 5 * 60 * 1000; // 5 minutes

    ns.disableLog('ALL');
    ns.print(`[INFO] Network Mapper/Analyzer started. Updating files every ${scanInterval / 60000} minutes.`);
    ns.tprint(`[INFO] Network Mapper/Analyzer started. See script logs for details. Files: ${analysisOutputFile}, ${connectionMapFile}`);

    const scriptRamCost = ns.getScriptRam('network-mapper.js', 'home');
    if (ns.getServerMaxRam('home') < scriptRamCost + ns.getServerUsedRam('home') && ns.getHostname() === 'home') {
        ns.tprint(`[ERROR] Not enough RAM on home to run network-mapper.js. Needs ~${ns.formatRam(scriptRamCost)}. Exiting.`);
        return;
    }

    while (true) {
        ns.print(`[INFO] Starting network scan and analysis...`);
        const allServers = getAllServers(ns);
        let analysisFileContent = `# Full network scan-analyze output\n`;
        analysisFileContent += `# Generated by network-mapper.js on ${new Date().toLocaleString()}\n\n`;
        let connectMapFileContent = `# Quick connect map - hostname: connect path\n`;
        connectMapFileContent += `# Generated by network-mapper.js on ${new Date().toLocaleString()}\n\n`;

        for (const server of allServers) {
            try {
                const analysisData = ns.scanAnalyze(server);
                
                analysisFileContent += `Server: ${server}\n`;
                if (analysisData && Array.isArray(analysisData.path)) {
                    analysisFileContent += `  Path: ${analysisData.path.join(' -> ')}\n`;
                } else {
                    analysisFileContent += `  Path: N/A or Invalid Path Data\n`;
                }
                analysisFileContent += `  Security: ${analysisData.security.toFixed(2)} / ${analysisData.minSecurity.toFixed(2)} (Min: ${analysisData.minSecurity.toFixed(2)})\n`;
                analysisFileContent += `  Money: $${ns.formatNumber(analysisData.money)} / $${ns.formatNumber(analysisData.maxMoney)} (Max: $${ns.formatNumber(analysisData.maxMoney)})\n`;
                analysisFileContent += `  Required Hacking: ${analysisData.reqHack}\n`;
                analysisFileContent += `  Root Access: ${analysisData.root}\n`;
                analysisFileContent += `  RAM: ${ns.formatRam(analysisData.ram)}\n`;
                analysisFileContent += `  Organization: ${analysisData.organization}\n`;
                analysisFileContent += `  Player Admin: ${analysisData.admin}\n`;
                analysisFileContent += `  Backdoor: ${analysisData.backdoored}\n`;
                analysisFileContent += `  Scan Depth: ${analysisData.scanDepth}\n`;
                analysisFileContent += `  Relative Chance: ${(analysisData.relativeChance * 100).toFixed(2)}%\n`;
                analysisFileContent += `---\n`;

                if (server !== "home") {
                    let connectCmd = "";
                    if (analysisData && Array.isArray(analysisData.path)) {
                        const pathArray = analysisData.path;
                        if (pathArray.length > 0) {
                            connectCmd = pathArray.map(p => `connect ${p}`).join('; ');
                        } else {
                            connectCmd = `connect ${server}`;
                        }
                        connectMapFileContent += `${server}: ${connectCmd}\n`;
                    } else {
                        ns.print(`[WARN] Path data for ${server} is invalid or missing. analysisData.path: ${JSON.stringify(analysisData ? analysisData.path : 'analysisData_is_null')}`);
                        connectMapFileContent += `${server}: Error processing path data.\n`;
                    }
                }

            } catch (e) {
                ns.print(`[WARN] Error during scanAnalyze or processing for ${server}: ${e.message}. Skipping.`);
                analysisFileContent += `Server: ${server}\n  Error during processing: ${e.message}\n---\n`;
                if (server !== "home") {
                    connectMapFileContent += `${server}: Error generating connect path (exception).\n`;
                }
            }
            await ns.sleep(25); 
        }

        try {
            await ns.write(analysisOutputFile, analysisFileContent, "w");
            ns.print(`[SUCCESS] Updated ${analysisOutputFile}.`);
            await ns.write(connectionMapFile, connectMapFileContent, "w");
            ns.print(`[SUCCESS] Updated ${connectionMapFile}.`);
        } catch (e) {
            ns.print(`[ERROR] Failed to write output files: ${e.message}`);
            ns.tprint(`[ERROR] Network Mapper failed to write files: ${e.message}`);
        }

        await ns.sleep(scanInterval);
    }
}

/**
 * Scans the network and returns a list of all server hostnames.
 * @param {NS} ns
 * @returns {string[]}
 */
function getAllServers(ns) {
    const servers = new Set();
    const queue = ['home']; 
    servers.add('home');

    let head = 0; 
    while(head < queue.length) { 
        const current = queue[head++]; 
        const neighbors = ns.scan(current);

        for (const neighbor of neighbors) {
            if (!servers.has(neighbor)) {
                servers.add(neighbor);
                queue.push(neighbor); 
            }
        }
    }
    return Array.from(servers);
} 